# 实验图表模板框架

> 论文：基于YOLOv11深度学习的智慧城市井盖状态检测系统
> 章节：第3章 实验验证及结果分析
> 日期：2026-02-07
> 状态：等待数据确认后填充

---

## Table 1: 与主流方法性能对比

**表格结构**（待填充数据）：

| 方法 | Backbone | mAP@0.5(%) | Precision(%) | Recall(%) | FPS | 参数量(M) |
|------|----------|------------|--------------|-----------|-----|-----------|
| Faster R-CNN | ResNet-50 | - | - | - | - | - |
| YOLOv5s | CSPDarknet | - | - | - | - | - |
| YOLOv8n | YOLOv8-B | - | - | - | - | - |
| YOLOv11n | YOLOv11-B | - | - | - | - | - |
| **本文方法** | **改进YOLOv11** | **-** | **-** | **-** | **-** | **-** |

**注**：粗体表示最优结果，FPS在RTX 4090 GPU上测试。

**需要的数据**：
- 各方法的mAP、Precision、Recall、FPS值
- 参数量统计

---

## Table 2: 各类状态检测精度

**表格结构**（待填充数据）：

| 类别 | AP(%) | Precision(%) | Recall(%) | 样本数 |
|------|-------|--------------|-----------|--------|
| 正常 | - | - | - | - |
| 破损 | - | - | - | - |
| 沉陷 | - | - | - | - |
| 凸起 | - | - | - | - |
| 缺失 | - | - | - | - |
| 移位 | - | - | - | - |
| 周边损坏 | - | - | - | - |
| **平均** | **-** | **-** | **-** | **-** |

**需要的数据**：
- 7类状态各自的AP、Precision、Recall
- 各类别样本数

---

## Table 3: 消融实验结果

**表格结构**（待填充数据）：

| 配置 | P2层 | AMSFF | STAA | DCH | mAP@0.5(%) | Δ(%) |
|------|------|-------|------|-----|------------|------|
| 基线 | - | - | - | - | - | - |
| +P2层 | ✓ | - | - | - | - | - |
| +AMSFF | ✓ | ✓ | - | - | - | - |
| +STAA | ✓ | ✓ | ✓ | - | - | - |
| **完整方法** | ✓ | ✓ | ✓ | ✓ | **-** | **-** |

**需要的数据**：
- 基线YOLOv11的mAP
- 逐步添加各模块后的mAP
- 各模块的增量贡献

---

## Fig.5: 性能对比柱状图

**图表类型**：分组柱状图

**数据结构**（待填充）：

```python
methods = ['Faster R-CNN', 'YOLOv5s', 'YOLOv8n', 'YOLOv11n', 'Ours']
mAP = [-, -, -, -, -]
precision = [-, -, -, -, -]
recall = [-, -, -, -, -]
fps = [-, -, -, -, -]
```

**绘图代码框架**：

```python
import matplotlib.pyplot as plt
import numpy as np

# 设置中文字体
plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False

# 数据（待填充）
methods = ['Faster R-CNN', 'YOLOv5s', 'YOLOv8n', 'YOLOv11n', 'Ours']
mAP = [85.3, 88.7, 90.4, 91.6, 93.2]  # 示例数据

fig, ax = plt.subplots(figsize=(10, 6))
colors = ['#7FB3D5', '#7FB3D5', '#7FB3D5', '#7FB3D5', '#E74C3C']
bars = ax.bar(methods, mAP, color=colors)

ax.set_ylabel('mAP@0.5 (%)', fontsize=12)
ax.set_ylim([80, 95])
ax.set_title('Performance Comparison with SOTA Methods', fontsize=14)

# 添加数值标签
for bar in bars:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width()/2., height,
            f'{height}%', ha='center', va='bottom', fontsize=11)

plt.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.savefig('Fig_5_性能对比.png', dpi=300, bbox_inches='tight')
```

---

## Fig.6: 混淆矩阵

**图表类型**：热力图

**数据结构**（待填充）：

```
              预测类别
          正常 破损 沉陷 凸起 缺失 移位 周边
      正常  ████   2    1    0    0    0    1
真   破损   3  ████   0    0    2    1    0
实   沉陷   1    0  ████   0    0    0    0
别   凸起   0    1    0  ████   0    2    1
    缺失   0    2    0    0  ████   0    0
    移位   0    1    0    1    0  ████   2
    周边   1    0    0    1    0    1  ████
```

**绘图代码框架**：

```python
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np

# 混淆矩阵数据（待填充）
confusion_matrix = np.array([
    [185,  2,  1,  0,  0,  0,  1],
    [  3,178,  0,  0,  2,  1,  0],
    [  1,  0,142,  0,  0,  0,  0],
    [  0,  1,  0, 95,  0,  2,  1],
    [  0,  2,  0,  0,108,  0,  0],
    [  0,  1,  0,  1,  0, 88,  2],
    [  1,  0,  0,  1,  0,  1, 75]
])

classes = ['正常', '破损', '沉陷', '凸起', '缺失', '移位', '周边']

plt.figure(figsize=(10, 8))
sns.heatmap(confusion_matrix, annot=True, fmt='d', cmap='Greens',
            xticklabels=classes, yticklabels=classes, cbar_kws={'label': '样本数'})
plt.xlabel('预测类别', fontsize=12)
plt.ylabel('真实类别', fontsize=12)
plt.title('Confusion Matrix of 7-Class Manhole Cover Status', fontsize=14)
plt.tight_layout()
plt.savefig('Fig_6_混淆矩阵.png', dpi=300, bbox_inches='tight')
```

---

## Fig.7: PR曲线

**图表类型**：多线图

**数据结构**（待填充）：

```python
# 7类状态的Precision-Recall曲线
classes = ['正常', '破损', '沉陷', '凸起', '缺失', '移位', '周边']
colors = ['#0072B2', '#D55E00', '#009E73', '#F0E442', '#CC79A7', '#F0E442', '#009E73']
AP_values = [-, -, -, -, -, -, -]  # 各类别的AP值
```

**绘图代码框架**：

```python
import matplotlib.pyplot as plt
import numpy as np

# PR曲线数据（待填充）
precision_dict = {
    '正常': {'recall': [...], 'precision': [...], 'ap': 95.2},
    '破损': {'recall': [...], 'precision': [...], 'ap': 89.3},
    # ... 其他类别
}

fig, ax = plt.subplots(figsize=(10, 8))

for class_name, data in precision_dict.items():
    ax.plot(data['recall'], data['precision'],
            label=f"{class_name} (AP={data['ap']:.1f}%)")

ax.set_xlabel('Recall', fontsize=12)
ax.set_ylabel('Precision', fontsize=12)
ax.set_title('Precision-Recall Curves for 7-Class Status', fontsize=14)
ax.legend(loc='lower left', fontsize=10)
ax.grid(alpha=0.3)
ax.set_xlim([0, 1])
ax.set_ylim([0, 1])

plt.tight_layout()
plt.savefig('Fig_7_PR曲线.png', dpi=300, bbox_inches='tight')
```

---

## Fig.8-11: 检测结果示例

**图片要求**：

| 图号 | 内容 | 数量 | 标注格式 |
|------|------|------|----------|
| Fig.8 | 成功检测案例 | 4-6张 | [类别] 置信度% |
| Fig.9 | 夜间场景 | 3-4张 | 同上 |
| Fig.10 | 雨雪场景 | 3-4张 | 同上 |
| Fig.11 | 困难负样本 | 3-4张 | 同上 |

**标注模板**：

```
┌─────────────────┐
│                 │
│   [正常] 94.2%  │
│                 │
└─────────────────┘
```

**布局建议**：

```
Fig.8: 检测结果示例
┌──────┐ ┌──────┐ ┌──────┐ ┌──────┐
│ 正常  │ │ 破损  │ │ 缺失  │ │ 被占  │
│ 94.2%│ │ 87.5%│ │ 92.1%│ │ 78.3%│
└──────┘ └──────┘ └──────┘ └──────┘
 晴天场景   多井盖   复杂背景   阴影干扰
```

---

## Fig.12: 特征可视化 (t-SNE)

**图表类型**：散点图

**数据需求**：

- 提取倒数第二层特征
- 使用t-SNE降维至2D
- 按7类状态着色

**绘图代码框架**：

```python
import matplotlib.pyplot as plt
from sklearn.manifold import TSNE

# 特征数据（待填充）
features = np.array([...])  # N × D
labels = np.array([...])    # N

# t-SNE降维
tsne = TSNE(n_components=2, random_state=42)
features_2d = tsne.fit_transform(features)

# 绘图
plt.figure(figsize=(10, 8))
for i, class_name in enumerate(classes):
    mask = labels == i
    plt.scatter(features_2d[mask, 0], features_2d[mask, 1],
                label=class_name, alpha=0.6)

plt.xlabel('t-SNE Dimension 1', fontsize=12)
plt.ylabel('t-SNE Dimension 2', fontsize=12)
plt.title('Feature Visualization using t-SNE', fontsize=14)
plt.legend(fontsize=10)
plt.tight_layout()
plt.savefig('Fig_12_特征可视化.png', dpi=300, bbox_inches='tight')
```

---

## Fig.13: 消融实验对比

**图表类型**：柱状图

**数据结构**（待填充）：

```python
configs = ['基线', '+P2层', '+AMSFF', '+STAA', '完整方法']
mAP_values = [-, -, -, -, -]
```

**绘图代码框架**：

```python
fig, ax = plt.subplots(figsize=(10, 6))
bars = ax.bar(configs, mAP_values, color='steelblue')

# 添加增量标注
for i, (bar, value) in enumerate(zip(bars, mAP_values)):
    if i > 0:
        delta = value - mAP_values[i-1]
        ax.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.5,
                f'+{delta:.1f}%', ha='center', fontsize=10, color='green')

ax.set_ylabel('mAP@0.5 (%)', fontsize=12)
ax.set_title('Ablation Study: Contribution of Each Module', fontsize=14)
ax.grid(axis='y', alpha=0.3)
plt.tight_layout()
plt.savefig('Fig_13_消融实验.png', dpi=300, bbox_inches='tight')
```

---

## Fig.14: Loss曲线

**图表类型**：折线图

**数据需求**：

- 训练过程中的Loss值
- 包含：总损失、分类损失、回归损失

**绘图代码框架**：

```python
# 训练日志数据（待填充）
epochs = range(1, 301)
total_loss = [...]
cls_loss = [...]
bbox_loss = [...]

fig, ax = plt.subplots(figsize=(12, 6))
ax.plot(epochs, total_loss, label='Total Loss', linewidth=2)
ax.plot(epochs, cls_loss, label='Classification Loss', linewidth=1.5, alpha=0.7)
ax.plot(epochs, bbox_loss, label='Bbox Loss', linewidth=1.5, alpha=0.7)

ax.set_xlabel('Epoch', fontsize=12)
ax.set_ylabel('Loss', fontsize=12)
ax.set_title('Training Loss Curve', fontsize=14)
ax.legend(fontsize=11)
ax.grid(alpha=0.3)
plt.tight_layout()
plt.savefig('Fig_14_Loss曲线.png', dpi=300, bbox_inches='tight')
```

---

## 数据需求汇总

### 从Technical Architect需要获取

| 数据项 | 用途 | 图表 |
|--------|------|------|
| 各方法mAP/Precision/Recall/FPS | Table 1, Fig.5 | 对比实验 |
| 7类状态各自的指标 | Table 2, Fig.6 | 细粒度分析 |
| 消融实验逐步结果 | Table 3, Fig.13 | 模块贡献 |
| PR曲线数据 | Fig.7 | 各类别性能 |
| 训练日志 | Fig.14 | Loss曲线 |
| 提取的特征向量 | Fig.12 | t-SNE可视化 |
| 检测结果图片 | Fig.8-11 | 可视化示例 |
| 混淆矩阵数据 | Fig.6 | 分类效果 |

### 实验环境信息

- GPU型号
- 显存大小
- CUDA版本
- PyTorch版本
- 训练时长

---

**文档创建人**: Academic Writer
**最后更新**: 2026-02-07
**状态**: 等待Technical Architect提供数据
